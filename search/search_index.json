{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Unpaginate Chain calls of paginated APIs Introduction API endpoints are often paginated, meaning that you must chain requests to get the content in full. Unpaginate provides a decorator to make that task easy: >>> from unpaginate import unpaginate >>> @unpaginate ... def get_cities(pagination, country): ... return requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"page\": pagination.page}, ... ).json()[\"items\"] Calling the decorated function allows to iterate over all items of all pages: >>> iterator = get_cities(\"France\") # the 'pagination' parameter is added by the decorator >>> iterator <generator object get_cities ...> >>> next(iterator) 'Paris' >>> next(iterator) 'Lyon' >>> next(iterator) 'Marseille' All pagination schemes are supported: By page index By offset Using a cursor Other schemes through avdanced mode Tip It's not just API calls! All functions can be decorated with unpaginate ! The requests module is used for illustrative purposes only. Installation Install Unpaginate with pip: $ python -m pip install unpaginate Python version support As a general rule, all Python versions that are both released and still officially supported are supported by unpaginate and tested against. If you have other use cases or find issues with some Python versions, feel free to open a ticket ! Status of the project Unpaginate is currently in alpha : the API may change in future releases. Changes are well detailed in the changelog , and the version numbering follow semver .","title":"Home"},{"location":"#unpaginate","text":"Chain calls of paginated APIs","title":"Unpaginate"},{"location":"#introduction","text":"API endpoints are often paginated, meaning that you must chain requests to get the content in full. Unpaginate provides a decorator to make that task easy: >>> from unpaginate import unpaginate >>> @unpaginate ... def get_cities(pagination, country): ... return requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"page\": pagination.page}, ... ).json()[\"items\"] Calling the decorated function allows to iterate over all items of all pages: >>> iterator = get_cities(\"France\") # the 'pagination' parameter is added by the decorator >>> iterator <generator object get_cities ...> >>> next(iterator) 'Paris' >>> next(iterator) 'Lyon' >>> next(iterator) 'Marseille' All pagination schemes are supported: By page index By offset Using a cursor Other schemes through avdanced mode Tip It's not just API calls! All functions can be decorated with unpaginate ! The requests module is used for illustrative purposes only.","title":"Introduction"},{"location":"#installation","text":"Install Unpaginate with pip: $ python -m pip install unpaginate","title":"Installation"},{"location":"#python-version-support","text":"As a general rule, all Python versions that are both released and still officially supported are supported by unpaginate and tested against. If you have other use cases or find issues with some Python versions, feel free to open a ticket !","title":"Python version support"},{"location":"#status-of-the-project","text":"Unpaginate is currently in alpha : the API may change in future releases. Changes are well detailed in the changelog , and the version numbering follow semver .","title":"Status of the project"},{"location":"decorator/","text":"The unpaginate decorator Assuming you have a function that returns (or yields) one page of items, the following changes must be performed to use the Unpaginate library: Decorate the function with @unpaginate(...) Add a pagination parameter as first parameter of the decorated function Use some attributes of pagination in the code to get the right items of the current page Tip If you decorate a class method instead of a function, the pagination parameter must be the second parameter instead, just after self . Note The pagination parameter is called by position and not by name, so you can use the / syntax from PEP 570 to reflect that. However, its name still needs to be called pagination . Decorator parameters These parameters can be passed when decorating the function. For example, decorate with @unpaginate(page=1) so that the index of the first page is 1 . page ( int ) The initial value of pagination.page . Defaults to 0 . offset ( int ) The initial value of pagination.offset . Defaults to 0 . context_factory (callable) This function is called with no arguments to create the initial value of pagination.context . If not present, the initial value is None . stop (callable) Allows to specify the stop condition . Defaults to stop_when_empty . Short form It is possible to decorate with @unpaginate as a shortcut for @unpaginate() .","title":"@unpaginate"},{"location":"decorator/#the-unpaginate-decorator","text":"Assuming you have a function that returns (or yields) one page of items, the following changes must be performed to use the Unpaginate library: Decorate the function with @unpaginate(...) Add a pagination parameter as first parameter of the decorated function Use some attributes of pagination in the code to get the right items of the current page Tip If you decorate a class method instead of a function, the pagination parameter must be the second parameter instead, just after self . Note The pagination parameter is called by position and not by name, so you can use the / syntax from PEP 570 to reflect that. However, its name still needs to be called pagination .","title":"The unpaginate decorator"},{"location":"decorator/#parameters","text":"These parameters can be passed when decorating the function. For example, decorate with @unpaginate(page=1) so that the index of the first page is 1 . page ( int ) The initial value of pagination.page . Defaults to 0 . offset ( int ) The initial value of pagination.offset . Defaults to 0 . context_factory (callable) This function is called with no arguments to create the initial value of pagination.context . If not present, the initial value is None . stop (callable) Allows to specify the stop condition . Defaults to stop_when_empty .","title":"Decorator parameters"},{"location":"decorator/#short","text":"It is possible to decorate with @unpaginate as a shortcut for @unpaginate() .","title":"Short form"},{"location":"pagination/","text":"Pagination instance The Pagination instance passed to the decorated functions as the argument pagination contains the following attributes: page ( int , read-only) The index of the current page. offset ( int , read-only) The index of the first item of the current page. context Arbitrary data. Used to pass data from one page to the other, or for stop conditions . is_last_page ( bool ) Setting this attribute to True indicates that the current page is the last one, so that the iteration is stopped and the next page is never called.","title":"Pagination"},{"location":"pagination/#pagination-instance","text":"The Pagination instance passed to the decorated functions as the argument pagination contains the following attributes: page ( int , read-only) The index of the current page. offset ( int , read-only) The index of the first item of the current page. context Arbitrary data. Used to pass data from one page to the other, or for stop conditions . is_last_page ( bool ) Setting this attribute to True indicates that the current page is the last one, so that the iteration is stopped and the next page is never called.","title":"Pagination instance"},{"location":"stop/","text":"Stop conditions By default, Unpaginate chains pages together until one page has no items. This is the default stop condition, which can be customized by specifying a callable to the stop parameter of the decorator: @unpaginate(stop=...) . Provided stop conditions >>> from unpaginate import ( ... stop_manual, ... stop_on_falsy_context, ... stop_on_page_smaller_than, ... stop_on_same_context, ... stop_when_empty, ... ) stop_manual Never stops. Useful to override the default behavior when stopping manually with pagination.is_last_page . stop_when_empty Default behavior. Stops when a page has no items. Same behavior as stop_on_page_smaller_than(1) . stop_on_page_smaller_than(page_size) Stops when the number of items in the page is strictly lower than the number passed as argument (e.g. stop_on_page_smaller_than(100) to stop when a page has 99 items or less). stop_on_falsy_context Stops when bool(pagination.context) is False . stop_on_same_context Stops when pagination.context at the end of a page is equal to its value at the beginning of the page. Combining stop conditions Stops conditions can be combined with | and & operators. For example, to stop when the context is falsy or equals to the one before the page, use: >>> from unpaginate import stop_on_falsy_context, stop_on_same_context, unpaginate >>> @unpaginate(stop=stop_on_falsy_context | stop_on_same_context) ... def fct(pagination): ... ... Custom stop conditions A stop condition is a callable that takes as parameters the Pagination instance at the beginning of the page and at the end of the page, and returns a boolean indicating if the iterations has to stop. For example, to stop when the value on the context stops increasing by one: >>> def my_stop(pagination_before, pagination_after): ... return pagination_before.context + 1 != pagination_after.context Tip The | and & operators will work as expected, assuming that one of the operands is a provided stop condition, e.g. my_stop | stop_on_page_smaller_than(100) . However, combining only custom stop conditions is not posible directly, instead start with stop_manual (because it does nothing): e.g. stop_manual | my_stop1 | my_stop2 .","title":"Stop condition"},{"location":"stop/#stop-conditions","text":"By default, Unpaginate chains pages together until one page has no items. This is the default stop condition, which can be customized by specifying a callable to the stop parameter of the decorator: @unpaginate(stop=...) .","title":"Stop conditions"},{"location":"stop/#provided","text":">>> from unpaginate import ( ... stop_manual, ... stop_on_falsy_context, ... stop_on_page_smaller_than, ... stop_on_same_context, ... stop_when_empty, ... ) stop_manual Never stops. Useful to override the default behavior when stopping manually with pagination.is_last_page . stop_when_empty Default behavior. Stops when a page has no items. Same behavior as stop_on_page_smaller_than(1) . stop_on_page_smaller_than(page_size) Stops when the number of items in the page is strictly lower than the number passed as argument (e.g. stop_on_page_smaller_than(100) to stop when a page has 99 items or less). stop_on_falsy_context Stops when bool(pagination.context) is False . stop_on_same_context Stops when pagination.context at the end of a page is equal to its value at the beginning of the page.","title":"Provided stop conditions"},{"location":"stop/#combine","text":"Stops conditions can be combined with | and & operators. For example, to stop when the context is falsy or equals to the one before the page, use: >>> from unpaginate import stop_on_falsy_context, stop_on_same_context, unpaginate >>> @unpaginate(stop=stop_on_falsy_context | stop_on_same_context) ... def fct(pagination): ... ...","title":"Combining stop conditions"},{"location":"stop/#custom","text":"A stop condition is a callable that takes as parameters the Pagination instance at the beginning of the page and at the end of the page, and returns a boolean indicating if the iterations has to stop. For example, to stop when the value on the context stops increasing by one: >>> def my_stop(pagination_before, pagination_after): ... return pagination_before.context + 1 != pagination_after.context Tip The | and & operators will work as expected, assuming that one of the operands is a provided stop condition, e.g. my_stop | stop_on_page_smaller_than(100) . However, combining only custom stop conditions is not posible directly, instead start with stop_manual (because it does nothing): e.g. stop_manual | my_stop1 | my_stop2 .","title":"Custom stop conditions"},{"location":"typing/","text":"Typing Unpaginate commes natively with type hints, which are checked by mypy . The benefits are twofold: Improve the correctness of the code of the library itself; Allow users of the library to benefit from well-defined type hints on the public API. As a rule of thumbs, we follow Postel's law by being as vague as possible for the arguments of functions, and as precise as possible for the returned values. Pagination The pagination parameter of the decorated functions can be annotated with Pagination , or if the context is used with Pagination[C] (replacing C with the type of the context): >>> from unpaginate import Pagination, stop_on_falsy_context, unpaginate >>> @unpaginate(page=1) ... def get_cities0(pagination: Pagination, country: str) -> Iterable[str]: ... return requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"page\": pagination.page}, ... ).json()[\"items\"] >>> @unpaginate(stop=stop_on_falsy_context) ... def get_cities2(pagination: Pagination[Optional[str]], country: str) -> Iterable[str]: ... data = requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"cursor\": pagination.context}, ... ).json() ... pagination.context = data.get(\"next_cursor\") ... return data[\"items\"] Tip In the second example, since no context_factory is specified, the initial value of the context is None . This is why the parameter of Pagination is Optional[str] and not simply str . This is not needed when a context_factory is specified: @unpaginate(context_factory=str) def foo(pagination: Pagination[str]) -> Iterable[str]: raise NotImplementedError Note Depending on the configuration of the tool you use for validating type hints, you may need to use the / syntax from PEP 570 to change the pagination parameter into a positional-only parameter, like so: >>> @unpaginate(page=1) ... def get_cities1(pagination: Pagination, /, country: str) -> Iterable[str]: ... ... Stop Annotate the two parameters of the stop callable with either Pagination or Pagination[C] (same C value for both parameters): >>> from unpaginate import Pagination >>> def my_stop_without_context( ... pagination_before: Pagination, ... pagination_after: Pagination, ... ) -> bool: ... return pagination_before.offset * 2 > pagination_after.offset >>> def my_stop_with_context( ... pagination_before: Pagination[int], ... pagination_after: Pagination[int], ... ) -> bool: ... return pagination_before.context + 1 != pagination_after.context","title":"Typing"},{"location":"typing/#typing","text":"Unpaginate commes natively with type hints, which are checked by mypy . The benefits are twofold: Improve the correctness of the code of the library itself; Allow users of the library to benefit from well-defined type hints on the public API. As a rule of thumbs, we follow Postel's law by being as vague as possible for the arguments of functions, and as precise as possible for the returned values.","title":"Typing"},{"location":"typing/#pagination","text":"The pagination parameter of the decorated functions can be annotated with Pagination , or if the context is used with Pagination[C] (replacing C with the type of the context): >>> from unpaginate import Pagination, stop_on_falsy_context, unpaginate >>> @unpaginate(page=1) ... def get_cities0(pagination: Pagination, country: str) -> Iterable[str]: ... return requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"page\": pagination.page}, ... ).json()[\"items\"] >>> @unpaginate(stop=stop_on_falsy_context) ... def get_cities2(pagination: Pagination[Optional[str]], country: str) -> Iterable[str]: ... data = requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"cursor\": pagination.context}, ... ).json() ... pagination.context = data.get(\"next_cursor\") ... return data[\"items\"] Tip In the second example, since no context_factory is specified, the initial value of the context is None . This is why the parameter of Pagination is Optional[str] and not simply str . This is not needed when a context_factory is specified: @unpaginate(context_factory=str) def foo(pagination: Pagination[str]) -> Iterable[str]: raise NotImplementedError Note Depending on the configuration of the tool you use for validating type hints, you may need to use the / syntax from PEP 570 to change the pagination parameter into a positional-only parameter, like so: >>> @unpaginate(page=1) ... def get_cities1(pagination: Pagination, /, country: str) -> Iterable[str]: ... ...","title":"Pagination"},{"location":"typing/#stop","text":"Annotate the two parameters of the stop callable with either Pagination or Pagination[C] (same C value for both parameters): >>> from unpaginate import Pagination >>> def my_stop_without_context( ... pagination_before: Pagination, ... pagination_after: Pagination, ... ) -> bool: ... return pagination_before.offset * 2 > pagination_after.offset >>> def my_stop_with_context( ... pagination_before: Pagination[int], ... pagination_after: Pagination[int], ... ) -> bool: ... return pagination_before.context + 1 != pagination_after.context","title":"Stop"},{"location":"usecases/","text":"Use cases The various uses cases in this page showcase representative examples of common pagination schemes. In most cases you will also be interested to learn about: Stop conditions : specify when the iteration will stop without calling the following page Values held by the pagination argument : values of the current page, item offset, arbitrary context, etc. Parameters of the @unpaginate decorator : for example to be able to specify the initial values of the pagination attributes By page index The value of the current page is held in pagination.page : >>> from unpaginate import unpaginate >>> @unpaginate(page=1) ... def get_cities0(pagination, country): ... return requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"page\": pagination.page}, ... ).json()[\"items\"] By offset The index of the first item of the current page is held in pagination.offset : >>> from unpaginate import stop_on_page_smaller_than, unpaginate >>> @unpaginate(stop=stop_on_page_smaller_than(100)) ... def get_cities1(pagination, country): ... return requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"start\": pagination.offset, \"limit\": 100}, ... ).json()[\"items\"] Using a cursor Arbitrary data can be passed from one page to the other via pagination.context ; this is ideal for API responses containing a cursor to fetch the next page. Get the cursor for the current page from the context, and write the cursor for the next page: >>> from unpaginate import stop_on_falsy_context, unpaginate >>> @unpaginate(stop=stop_on_falsy_context) ... def get_cities2(pagination, country): ... data = requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"cursor\": pagination.context}, ... ).json() ... pagination.context = data.get(\"next_cursor\") ... return data[\"items\"] Advanced usage The usages above are the more frequent ones. Others can be implemented manually by combining some of the following building blocks: Getting the page and item offset values through pagination.page and pagination.offset respectively Passing arbitrary data from one page to the other though the pagination.context attribute Specifying manually when the last page is reached by setting pagination.is_last_page to True , and avoid stopping on the first empty page by using @unpaginate(stop=stop_manual)","title":"Use cases"},{"location":"usecases/#use-cases","text":"The various uses cases in this page showcase representative examples of common pagination schemes. In most cases you will also be interested to learn about: Stop conditions : specify when the iteration will stop without calling the following page Values held by the pagination argument : values of the current page, item offset, arbitrary context, etc. Parameters of the @unpaginate decorator : for example to be able to specify the initial values of the pagination attributes","title":"Use cases"},{"location":"usecases/#by-page","text":"The value of the current page is held in pagination.page : >>> from unpaginate import unpaginate >>> @unpaginate(page=1) ... def get_cities0(pagination, country): ... return requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"page\": pagination.page}, ... ).json()[\"items\"]","title":"By page index"},{"location":"usecases/#by-offset","text":"The index of the first item of the current page is held in pagination.offset : >>> from unpaginate import stop_on_page_smaller_than, unpaginate >>> @unpaginate(stop=stop_on_page_smaller_than(100)) ... def get_cities1(pagination, country): ... return requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"start\": pagination.offset, \"limit\": 100}, ... ).json()[\"items\"]","title":"By offset"},{"location":"usecases/#by-cursor","text":"Arbitrary data can be passed from one page to the other via pagination.context ; this is ideal for API responses containing a cursor to fetch the next page. Get the cursor for the current page from the context, and write the cursor for the next page: >>> from unpaginate import stop_on_falsy_context, unpaginate >>> @unpaginate(stop=stop_on_falsy_context) ... def get_cities2(pagination, country): ... data = requests.post( ... \"https://api.example.org/cities\", ... json={\"country\": country, \"cursor\": pagination.context}, ... ).json() ... pagination.context = data.get(\"next_cursor\") ... return data[\"items\"]","title":"Using a cursor"},{"location":"usecases/#advanced","text":"The usages above are the more frequent ones. Others can be implemented manually by combining some of the following building blocks: Getting the page and item offset values through pagination.page and pagination.offset respectively Passing arbitrary data from one page to the other though the pagination.context attribute Specifying manually when the last page is reached by setting pagination.is_last_page to True , and avoid stopping on the first empty page by using @unpaginate(stop=stop_manual)","title":"Advanced usage"}]}